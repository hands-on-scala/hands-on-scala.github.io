<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Patternmatching on Hands-on Scala Blog</title>
    <link>http://hands-on-scala.github.io/categories/patternmatching/</link>
    <description>Recent content in Patternmatching on Hands-on Scala Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 06 May 2016 17:30:00 +0200</lastBuildDate>
    <atom:link href="http://hands-on-scala.github.io/categories/patternmatching/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Basic pattern matching in Scala</title>
      <link>http://hands-on-scala.github.io/post/patternmatch1/</link>
      <pubDate>Fri, 06 May 2016 17:30:00 +0200</pubDate>
      
      <guid>http://hands-on-scala.github.io/post/patternmatch1/</guid>
      <description>

&lt;h1 id=&#34;why-should-we-care-about-pattern-matching:709c56cceaa353d481f380974d67f3c0&#34;&gt;Why should we care about pattern matching?&lt;/h1&gt;

&lt;p&gt;Pattern matching is a quite commonly used &amp;ldquo;programming pattern&amp;rdquo; in functional languages, because it
fits nicely into the &amp;ldquo;functional way of thinking&amp;rdquo;, and it is quite powerful and handy as a tool.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s somewhat similar to a sequence of &lt;em&gt;if / else&lt;/em&gt; statements or to the &lt;em&gt;switch&lt;/em&gt; statement
of Java or C, but it is much more powerful, because it lets you form more complex
conditions for matching, even for the inside of an object.
In some cases
&lt;!-- (when dealing with objects of _case classes_ for example; we&#39;ll learn about them a bit later in more detail) --&gt;
Scala can automatically &lt;em&gt;decompose&lt;/em&gt; an object that you want to match and look inside it to check
if its structure matches your expectations.&lt;/p&gt;

&lt;!--This means 
that you can apply rules based on the object&#39;s type or inner structure without having 
to manually disassemble the object into its parts.--&gt;

&lt;p&gt;But, before going too deep, let&amp;rsquo;s see some examples.&lt;/p&gt;

&lt;h2 id=&#34;example-1-matching-value:709c56cceaa353d481f380974d67f3c0&#34;&gt;Example 1: matching value&lt;/h2&gt;

&lt;p&gt;Here the object what we match to patterns is &lt;em&gt;x&lt;/em&gt;, an integer.

object MatchTest1 extends App {
  def matchTest(x: Int): String = x match {
    case 1 =&gt; &#34;one&#34;
    case 2 =&gt; &#34;two&#34;
    case _ =&gt; &#34;many&#34;
  }
  println(matchTest(3))
}

Fairly simple, isn&amp;rsquo;t it? Just use the &lt;em&gt;match&lt;/em&gt; keyword after the name of the
thing you&amp;rsquo;ll want to match, and list your cases within curly braces.
The match expression in our case will return the value that appears on the right side of the &amp;lsquo;=&amp;gt;&amp;rsquo; arrow, corresponding
to the first matching case. So the order of the _case_s will matter if there is some overlap among the left sides of the arrows!&lt;/p&gt;

&lt;p&gt;One importatnt thing to note is the last case where an underscore is used: this is Scala&amp;rsquo;s notation
for &amp;ldquo;match anything&amp;rdquo;. Without this line, we would get a &amp;ldquo;scala.MatchError&amp;rdquo; because we called
the &lt;em&gt;matchTest()&lt;/em&gt; function with the value 3, which is not covered by the other &lt;em&gt;case&lt;/em&gt; branches.&lt;/p&gt;

&lt;p&gt;So the main point to remember from here is that you should be sure to cover all
possible options when using a &lt;em&gt;match&lt;/em&gt; expression if you want to avoid ugly errors.
The fail-safe option usually is to use the underscore as the last &lt;em&gt;case&lt;/em&gt;.
It will define a default path for the program flow for &amp;ldquo;all other cases&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;(Note: I just copied this example from the
&lt;a href=&#34;http://docs.scala-lang.org/tutorials/tour/pattern-matching.html&#34;&gt;official documentation&lt;/a&gt;).&lt;/p&gt;

&lt;h2 id=&#34;example-2-matching-type:709c56cceaa353d481f380974d67f3c0&#34;&gt;Example 2: matching type&lt;/h2&gt;

&lt;p&gt;If we want to write a function that behaves differently for different input &lt;em&gt;types&lt;/em&gt;, we can write something like:

def getType(x: Any): String = {
  x match {
    case x: String =&gt; &#34;String&#34;
    case x: Integer =&gt; &#34;Int&#34;
    case _ =&gt; &#34;I don&#39;t know&#34;
  }
}

The main difference from the previous example is that now we used &lt;em&gt;&amp;ldquo;x: Type&amp;rdquo;&lt;/em&gt; instead of a specified value on the left side
of the arrow, after the &lt;em&gt;case&lt;/em&gt; keyword. It&amp;rsquo;s still simple :)&lt;/p&gt;

&lt;p&gt;Note 1: &amp;ldquo;&lt;em&gt;Any&lt;/em&gt;&amp;rdquo; is a general type in Scala, similar to the &amp;ldquo;&lt;em&gt;Object&lt;/em&gt;&amp;rdquo; of Java, which is an ancestor of all other types.&lt;/p&gt;

&lt;p&gt;Note 2: You don&amp;rsquo;t need to use the same value name in the cases, because each
case has its own scope with regards of the incoming
object to be matched. Just be sure to use the same name on both sides of the arrow within a case line.

  def getType2(x: Any): String = {
    x match {
      case a: String =&gt; &#34;String: &#34; + a
      case b: Integer =&gt; &#34;Int: &#34; + b
      case _ =&gt; &#34;I don&#39;t know&#34;
    }
  }
&lt;/p&gt;

&lt;h2 id=&#34;example-3-using-guards:709c56cceaa353d481f380974d67f3c0&#34;&gt;Example 3: using guards&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s say we need some extra conditions to be true before applying the right side of a &lt;em&gt;case&lt;/em&gt;.
Scala lets us perform these additional checks within any of the cases independently, as in the
following example:

def getType3(x: Any): String = {
  x match {
    case a: String if a.startsWith(&#34;He&#34;) =&gt; &#34;String with &#39;He&#39;&#34;
    case b: Integer if b &gt; 0 =&gt; &#34;Positive integer&#34;
    case _ =&gt; &#34;I don&#39;t know&#34;
  }
}

These additional conditions before the cases&amp;rsquo; arrows are called &amp;ldquo;guards&amp;rdquo;.
If they are evaluated to false, then
the corresponding case branch is considered not matching, so the next case will be tried.&lt;/p&gt;

&lt;h2 id=&#34;example-4-matching-structure:709c56cceaa353d481f380974d67f3c0&#34;&gt;Example 4: matching structure&lt;/h2&gt;

&lt;p&gt;I promised in the first paragraph that in some cases we will be able to
&amp;ldquo;automatically &lt;em&gt;decompose&lt;/em&gt; an object&amp;rdquo; to look inside it and check
if its structure matches our expectations.&lt;/p&gt;

&lt;p&gt;How does it work in Scala, and what are the prerequisites?&lt;/p&gt;

&lt;p&gt;The answer is: &lt;em&gt;case classes&lt;/em&gt;! My next blog post will cover them in more detail.
For now let&amp;rsquo;s think about a case class as a composite object with some
auto-magic: automatically generated constructors and getters, for example.&lt;/p&gt;

&lt;p&gt;For the more curious, here are
&lt;a href=&#34;http://stackoverflow.com/questions/2312881/what-is-the-difference-between-scalas-case-class-and-class%29&#34;&gt;some nice and short explanations&lt;/a&gt;, and the official (quite dense) &lt;a href=&#34;http://docs.scala-lang.org/tutorials/tour/case-classes.html&#34;&gt;description of case classes&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So, for an example of automatic decomposition, at first we need a
case class. We&amp;rsquo;ll write one, representing a tweet message, that has three parts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;an identifier (&lt;em&gt;id: Long&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;an author (&lt;em&gt;author: User&lt;/em&gt;, that itself could be a complex case class, now it only contains one String, a name)&lt;/li&gt;
&lt;li&gt;a message (&lt;em&gt;msg: String&lt;/em&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Defining these new types (&lt;em&gt;User&lt;/em&gt; and &lt;em&gt;TweetMsg&lt;/em&gt;) in Scala takes only two fairly short lines:&lt;/p&gt;

&lt;p&gt;
case class User(name: String)
case class TweetMsg(id: Long, user: User, msg: String)
&lt;/p&gt;

&lt;p&gt;And now a function can match a tweet&amp;rsquo;s inners like this:&lt;/p&gt;

&lt;p&gt;
def processTweet(tweet: TweetMsg) = tweet match {
  case TweetMsg(id, _, _) if id &lt; 0 =&gt; &#34;Invalid (negative) tweet id!&#34;
  case TweetMsg(_, user, _) if user.name == &#34;adorster&#34; =&gt; &#34;Hello, &#34; + user.name + &#34;!&#34;
  case _ =&gt; &#34;Just another tweet&#34;
}
&lt;/p&gt;

&lt;p&gt;Example codes with tests are available at &lt;a href=&#34;https://github.com/ador/scala-examples/tree/master/02_pattern_match_app&#34;&gt;my scala-examples github repo&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Note &lt;em&gt;n +1&lt;/em&gt; : Until I set up a comments section somehow here, feedback is welcome via &lt;a href=&#34;https://twitter.com/adorster&#34;&gt;Twitter&lt;/a&gt; :)&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>